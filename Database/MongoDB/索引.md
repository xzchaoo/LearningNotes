# 索引类型 #

## 普通 ##
可以指定排序方式

db.xxx.createIndex({username:1})

内嵌文档属性也可以有索引
db.xxx.createIndex({'name.first':1})

还可以将索引建在内嵌文档上, 感觉并不是很有用
db.xxx.createIndex({name:1})
name是一个内嵌文档{first,last}
查询的时候要求name内嵌文档完全匹配


> _id自动有一个唯一的索引

## HASHED ##
HASHED索引不能是unique的
支持分片
支持按key查询, 但不支持范围查询
要求数据具有一定的随机性

## 单字段索引 ##
只对一个字段进行索引, 可以是内嵌文档的字段

## 复合索引 ##
1表示递增, -1表示递减
复合索引里不能包含hash索引
复合索引的顺序 跟 它是否可以用于sort有关


## 多key索引 ##
当对一个数组做索引的时候, 索引里的每个取值都会建立一个索引
这可以用于作为关键字搜索, 当然这绝对比不上那些专门做关键字搜索的引擎, 比如ES

# 索引特性 #
## unique ##


## partital ##
仅当某条件成立的时候才对数据进行索引

## sparse ##
是一个具体的partital, 当某个字段存在的时候才进行索引

## TTL ##
可以对一个date字段设置一个ttl属性N秒, 表示这个文档要在这个时间之后的N秒删除

在副本集上使用TTL时, 只有primary会定期删除数据

## Collation ##
可以用于字符串, 用于处理不同国家对字符串的比较的问题

# 概念 #

## 覆盖查询 ##
当查询条件 和 project 没有涉及到除了索引外的字段时, 就称为覆盖查询, 此时效率非常高

## 索引交集 ##
查询的时候生效的索引不止1个, 可以用多个索引来共同执行一个查询
当然这并不一定提高效率, 得看具体情况

假设item和qty上都有索引, 那么下面的可以用索引交集
```
db.i1.find({
    $or: [{ item: 'i1' }, { qty: { $lt: 15 }}]
}).explain()
```

对索引前缀也是支持的
