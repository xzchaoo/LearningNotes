http://www.redis.io/topics/persistence
Redis目前有两种持久化方式
1. RDB
	1. 每个一段时间将内存快照保存到磁盘上, 以提供持久性
	2. 时间间隔一般会比较大, 因为它要保存的东西多, 有可能造成数据丢失(因为有间隔)
	3. 恢复速度快
	4. 对性能影响比较小
	5. 是单个压缩了的文件
	6. 当内存里数据很多的时候比较耗费时间, 一般来说这个备份过程是一个子进程做的
		1. 当达到了某个save n m的要求
		2. 启动一个子进程
		3. 将内存数据写入到临时的RDB文件
		4. 完成之后用它替换旧的RDB文件
	7. 需要指定形如save n m的参数
		1. 意思是n秒内如果发生了m次修改操作, 就执行一次fsync
		2. 可以有多个save n m 只要他们组合起来合理
2. AOF
	1. 可以记录你的操作日志, 这样当重启Redis的时候, 就可以重播日志, 以达到持久化的效果
	2. 频率一般比较高, 比如 1秒写一次 每个操作写一次 交给系统缓存决定 这三种
	3. appendonly模式 当日志文件太大的时候 会进行日志文件的重写 以缩小日志文件
	4. 日志文件的重写指的是将当前内存里的值全部(尽量)以 set key value的方式保存, 以减少日志量, 反正我现在最新值就是这样了, 省的你以后一直重播操作
	5. 比RDB安全, 更持久化
	6. 文件通常比RDB大
	7. 需要启动 appendonly yes
	8. 日志重写
		1. 频率 : 每条命令, 每秒(建议), 交给操作系统管理
		2. 如何工作?
			1. 开一个子进程
			2. 子进程根据当前内存数据开始产生一个临时的AOF文件
			3. 同时父进程将此后的所有写到AOF文件的命令又备份一份到buffer里, 注意是"又", 改写AOF文件还是要写AOF文件!
			4. 等子进程做完之后, 父进程再将buffer追加到临时的AOF文件里, 当然这里要做一个同步, 保证这个过程没有任何的新命令
			5. 然后用临时的AOF替换旧的AOF, 注意此时一般临时的AOF会比旧的AOF小得多, 但是他们重播起来的效果是完全一样的!
	9. AOF文件坏了怎么办?
		1. 先备份一下AOF文件
		2. 执行redis-check-aof --fix
		3. 执行diff -u检查前后两个文件的区别
	
3. RDB和AOF可以一起用
	1. 如果两者一起用, 那么当Redis重启时, 会使用AOF来进行恢复, 因为AOF总是比RDB更安全一些, 但速度更慢
	2. 在已经使用RDB的请求下, 如何切换到AOF? 或混合使用AOF? 这同样可以解决:如果利用RDB文件进行恢复到一个支持AOF的Redis.
		1. 不能轻易的直接将appendonly设置成yes就完事了
		2. 因为此时aof文件是空的, 而你内存其实是有数据的
		3. 如果你重启了, 那么redis会用aof文件来进行恢复, 而你文件却几乎是空的
		4. 正确的做法是:
			1. 先执行一下save命令(在比较空闲的情况下), 或执行bgsave 或 干脆就不执行了
			2. 等save命令完成之后备份一下rdb文件, 或等待bgsave完成再备份rdb文件(bgsave由于是后台备份, 因此要看时间戳是否变化)
			3. 执行config set appendonly yes
			4. 此时redis会阻塞住, 然后开始生成一个初始化的aof文件, 把当前的内存数据写入到aof里
			5. 等阻塞结束之后将配置文件里的appendonly设置成yes, 如果忘记这步可能重启一下服务器, AOF就被关了
			6. 这样就OK了
	3. Redis会尽量在导出RDB的时候不去生成AOF, 因为导出RDB的时候比较耗费I/O, 如果还写AOF, 那大家都慢
		1. 有一个参数可以调整这个行为
		2. 这可能会导致AOF丢失一部分数据