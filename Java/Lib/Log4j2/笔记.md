# 优势 #
1. 比 log4j 性能更好
2. 提供更多功能
3. 支持接口和实现分离
4. 异步
5. 原子性重新加载配置
6. 提供一些过滤功能
7. 定制日志级别

# 一些概念 #
![结构图](http://logging.apache.org/log4j/2.x/images/Log4jClasses.jpg)

Logger 有一个名字
LoggerConfig 有一个名字

Configuration 每个LC有一个Configuration
它包含了 Appender Filter 等

Level
关于等级的继承跟以前也是一样的
只有大于或等于这个级别的消息才会被记录日志

Filter
1. 在一个消息被传给LC之前进行过滤
2. 在传给LC之后, 在Appender之前进行过滤
3. 在每个Appender处也可以进行过滤

Although an event may be accepted by a Filter the event still might not be logged. This can happen when the event is accepted by the pre-LoggerConfig Filter but is then denied by a LoggerConfig filter or is denied by all Appenders.

可以有多个 Filter 对同一个消息进行过滤
每个Filter返回
Accept 一旦有filter返回它, 就不会在调用其他的filter了, 马上接受
Deny 一旦有filter返回它, 就不会调用其他filter了, 马上拒绝
Neutral 中立, 看其他的filter的结果

Layout

一般情况下 Logger 跟一个 LoggerConfig 相关, 并且他们名字相同
但是可能某个Logger并没有提供配置, 因此他会使用它的父亲的 LoggerConfig, 直到根 LoggerConfig

Logger 的继承是通过 LoggerConfig 来实现的
名字为 com.foo 的LC 是 名字为 com.foo.bar 的父亲

# 杂 #
additivity="false" 的作用是 阻断当前分支点不会再使用与父节点的 appender


EventLogger
级别是OFF
The EventLogger class uses a Logger named "EventLogger". EventLogger uses a logging level of OFF as the default to indicate that it cannot be filtered. These events can be formatted for printing using the StructuredDataLayout.

# ThreadContext #
Including the ThreadContext when writing logs

The PatternLayout provides mechanisms to print the contents of the ThreadContext Map and Stack.

Use %X by itself to include the full contents of the Map.
Use %X{key} to include the specified key.
Use %x to include the full contents of the Stack.


# Marker #
marker 用于 filter的筛选 , 它本身一般不会出现在日志的输出结果上

# 配置 #
<properties>里的元素将会被自动放到 ThreadContextMap 里

必须配置Root Logger

# Properties #
```
<Properties>
    <Property name="filename">target/test.log</Property>
    <Property name="filename" value="这样也行"/>
  </Properties>
```
属性占位符 ${name} 的语法


# Appenders #
```
  <Appenders>
    <Console name="STDOUT">
      <PatternLayout pattern="%m MDC%X%n"/>
    </Console>
    <Console name="FLOW">
      <!-- this pattern outputs class name and line number -->
      <PatternLayout pattern="%C{1}.%M %m %ex%n"/>
      <filters>
        <MarkerFilter marker="FLOW" onMatch="ACCEPT" onMismatch="NEUTRAL"/>
        <MarkerFilter marker="EXCEPTION" onMatch="ACCEPT" onMismatch="DENY"/>
      </filters>
    </Console>
    <File name="File" fileName="${filename}">
      <PatternLayout>
        <pattern>%d %p %C{1.} [%t] %m%n</pattern>
      </PatternLayout>
    </File>
    <List name="List">
    </List>
  </Appenders>
```

# Loggers #
```
  <Loggers>
    <Logger name="org.apache.logging.log4j.test1" level="debug" additivity="false">
      <ThreadContextMapFilter>
        <KeyValuePair key="test" value="123"/>
      </ThreadContextMapFilter>
      <AppenderRef ref="STDOUT"/>
    </Logger>
 
    <Logger name="org.apache.logging.log4j.test2" level="debug" additivity="false">
      <Property name="user">${sys:user.name}</Property>
      <AppenderRef ref="File">
        <ThreadContextMapFilter>
          <KeyValuePair key="test" value="123"/>
        </ThreadContextMapFilter>
      </AppenderRef>
      <AppenderRef ref="STDOUT" level="error"/>
    </Logger>
 
    <Root level="trace">
      <AppenderRef ref="List"/>
    </Root>
  </Loggers>
```

# Filters #
CompositeFilter 用于套住很多的filter
因此只允许放一个filter元素
```
<Filters>
    <Marker marker="EVENT" onMatch="ACCEPT" onMismatch="NEUTRAL"/>
    <DynamicThresholdFilter key="loginId" defaultThreshold="ERROR"
                            onMatch="ACCEPT" onMismatch="NEUTRAL">
      <KeyValuePair key="User1" value="DEBUG"/>
    </DynamicThresholdFilter>
  </Filters>
```

BurstFilter 用于控制 LogEvents 的最大速率
<BurstFilter level="INFO" rate="16" maxBurst="100"/>

MapFilter
要求MapMessage里含有你指定的key/value
可以指定多个key/value, 可以是or或and的关系

MarkerFilter
根据marker进行过滤

StructuredDataFilter
用于过滤事件
id id.name type message

ThreadContextMapFilter
要求TCM里有相应的key/value

ThresholdFilter
如果当前的消息的等级比它指定的等级还要高就接受

TimeFilter
<TimeFilter start="05:00:00" end="05:30:00" onMatch="ACCEPT" onMismatch="DENY"/>

 

# Layout #
http://logging.apache.org/log4j/2.x/manual/layouts.html
JSONLayout
产生 locationInfo(需要通过反射拿到当前代码所在的位置) 代价比较大

PatternLayout
重点是要掌握很多的占位符
<PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %class - %msg%xEx%n"/>
时间 %d{yyyy-MM-dd HH:mm:ss.SSS}
c 所使用的logger的名字, 可以控制输出多少节, 比如 org.xzc.User 有3节
m 或 msg 或 message 记录的消息
M 调用所在的方法名 [※]
l 方法调用所在的行信息 org.xzc.learn.log4j2.Main.main(Main.java:54) [※]
L 行号 [※]
marker 包含marker及其父亲
markerSimpleName 不包含parents
n换行符
p 或 level 日志级别 %-5level 左对齐, 长度5
X{key}

[※]表示会有性能损失