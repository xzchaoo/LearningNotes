follower 收到写请求会转发给leader
读请求直接本地处理掉
zxid = ZooKeeper transaction ID = epoch + counter

一开始所有的服务器属于LOOKING状态
然后开始寻找是否已经存在leader, 如果存在就依附于它
如果没有, 那么开始选举:
1. 将自己的 (serverId,最大的zxid) 发给其他的所有服务器
2. 当一个服务器收到来自别的服务器的(sid,zxid)时, 跟自己的(sid,zxid)比较
	1. 保留zxid最大的, 在zxid相等的情况下, 保留sid最大的
3. 如果选择了对方传过来的, 那么当前服务器需要再次向其他所有服务器发送新的(sid,zxid)对
4. 直到最后, 有一个服务器它发出去的和它收到的

每当有新的选举 epoch 就会增加



# 配置 #
```
仅仅是一个名字而已
<dubbo:application name="hello-world-app"  />

使用zookeeper用于服务发现
<dubbo:registry address="127.0.0.1:2181" protocol="zookeeper" />

在20880暴露端口
<dubbo:protocol name="dubbo" port="20880" />

暴露一个服务
<dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" />
<bean id="demoService" class="com.alibaba.dubbo.demo.provider.DemoServiceImpl" />


引用一个服务
<dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService" />
```

```
<dubbo:service/> 服务配置，用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心。
<dubbo:reference/> 引用配置，用于创建一个远程服务代理，一个引用可以指向多个注册中心。
<dubbo:protocol/> 协议配置，用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受。
<dubbo:application/> 应用配置，用于配置当前应用信息，不管该应用是提供者还是消费者。
<dubbo:module/> 模块配置，用于配置当前模块信息，可选。
<dubbo:registry/> 注册中心配置，用于配置连接注册中心相关信息。
<dubbo:monitor/> 监控中心配置，用于配置连接监控中心相关信息，可选。
<dubbo:provider/> 提供方的缺省值，当ProtocolConfig和ServiceConfig某属性没有配置时，采用此缺省值，可选。
<dubbo:consumer/> 消费方缺省配置，当ReferenceConfig某属性没有配置时，采用此缺省值，可选。
<dubbo:method/> 方法配置，用于ServiceConfig和ReferenceConfig指定方法级的配置信息。
<dubbo:argument/> 用于指定方法参数配置。
```

1. 方法级配置 > 接口级配置 > 全局配置
	1. 比如方法的timeout
2. 会引入 dubbo.properties
	1. JVM参数 > XML配置 > dubbo.properties
3. 支持注解配置, 使用 dubbo 的  @Service, 并且启动dubbo的组件扫描
	1. 消费者使用 @Reference(version="1.0.0") private FooService fooService; 的方式也可以引用, 同样需要启动功能组件扫描

## 方法及配置 ##
超时 充实字数

## 启动时检查 ##
check=true 默认在启动的时候回检查所引用的服务是否可用, 如果服务的启动顺序不一样的话就会导致错误
设置check=false, 会延迟到第一次调用的时候才检查, 因此一个消费者只有第一次调用的时候才会去连接注册中心, 这可以处理循环依赖

默认会进行 注册中心检查 和 访问检查
可以在 registry 和 consumer或reference上check=false
```
dubbo.reference.com.foo.BarService.check=false
dubbo.reference.check=false
dubbo.consumer.check=false
dubbo.registry.check=false
```

默认代理对象是延迟初始化的, 可以强制饥饿加载
```
<dubbo:reference interface="com.foo.BarService" init="true" />
```

## 集群容错模式 ##
## 负载均衡 ##

## 协议 ##
<dubbo:protocol name="dubbo" dispatcher="all" threadpool="fixed" threads="100" />

```Dispatcher
all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。
direct 所有消息都不派发到线程池，全部在IO线程上直接执行。
message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在IO线程上执行。
execution 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在IO线程上执行。
connection 在IO线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。
```

## 直连提供者 ##
<dubbo:reference id="xxxService" interface="com.alibaba.xxx.XxxService" url="dubbo://localhost:20890" />

优先级最高, key是服务接口名
java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890

如果东西比较多
```
(用-Ddubbo.resolve.file指定映射文件路径，此配置优先级高于<dubbo:reference>中的配置，1.0.15及以上版本支持)
(2.0以上版本自动加载${user.home}/dubbo-resolve.properties文件，不需要配置)
```

## 不注册 ##
```
<dubbo:registry address="10.20.153.10:9090" register="false" />
```
这样服务就不会注册到注册中心上

## 只注册 ##


## 服务分组/版本 ##
```
<dubbo:reference id="barService" interface="com.foo.BarService" version="*" />
```

## 验证 ##

## RpcContext ##
隐式传参

## 异步调用 ##

## 回调 ##
支持将回调传到服务提供者处(其实是个代理), 服务提供者可以调用该回调
然后该回调通过代理会在消费者本地执行

## 事件 ##
支持onreturn onthrow事件

## Stub ##



## 杂 ##
1. 
默认情况下 所有的服务都会在本地暴露一份, 并且在注册中心也暴露一份
默认会优先引用本地服务
```
强制只在远程暴露
<dubbo:reference ... scope="remote" />
```
2. 服务可以注册到多个注册中心上, 但引用的时候必须唯一registry, 但在不同注册中心上引用服务多次





# 执行 #
将该配置文件引入到spring环境里就行了


# 服务的可执行jar包 #
com.alibaba.dubbo.container.Main


# 杂 #
