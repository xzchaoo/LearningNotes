http://docs.jboss.org/hibernate/validator/5.2/reference/en-US/html/ch02.html

1. 需要做检查的地方很多
2. 通常在 business layer 对bean做一些属性上的合法性检查 和 一些逻辑性的检查(比如用户id是否存在)是少不了的
3. 我们需要一个集中处理的地方

通常会将验证的元数据写入到 domain model 上

简单的例子:
1. 导包
```
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>5.2.4.Final</version>
</dependency>
```
2. 导入el支持, hibernate的实现需要el的支持, 如果你是在SE环境, 那么需要以下两个包的支持
```
<dependency>
    <groupId>javax.el</groupId>
    <artifactId>javax.el-api</artifactId>
    <version>2.2.4</version>
</dependency>
<dependency>
    <groupId>org.glassfish.web</groupId>
    <artifactId>javax.el</artifactId>
    <version>2.2.4</version>
</dependency>
```
3. 写一个 简单的类
```
public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}
```
4. 测试类
```
public class CarTest {

    private static Validator validator;

    @BeforeClass
    public static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void manufacturerIsNull() {
        Car car = new Car( null, "DD-AB-123", 4 );

        Set<ConstraintViolation<Car>> constraintViolations =
                validator.validate( car );

        assertEquals( 1, constraintViolations.size() );
        assertEquals( "may not be null", constraintViolations.iterator().next().getMessage() );
    }

    @Test
    public void licensePlateTooShort() {
        Car car = new Car( "Morris", "D", 4 );

        Set<ConstraintViolation<Car>> constraintViolations =
                validator.validate( car );

        assertEquals( 1, constraintViolations.size() );
        assertEquals(
                "size must be between 2 and 14",
                constraintViolations.iterator().next().getMessage()
        );
    }

    @Test
    public void seatCountTooLow() {
        Car car = new Car( "Morris", "DD-AB-123", 1 );

        Set<ConstraintViolation<Car>> constraintViolations =
                validator.validate( car );

        assertEquals( 1, constraintViolations.size() );
        assertEquals(
                "must be greater than or equal to 2",
                constraintViolations.iterator().next().getMessage()
        );
    }

    @Test
    public void carIsValid() {
        Car car = new Car( "Morris", "DD-AB-123", 2 );

        Set<ConstraintViolation<Car>> constraintViolations =
                validator.validate( car );

        assertEquals( 0, constraintViolations.size() );
    }
}
```


使用 @Valid 可以将验证扩散到其他类
提供商会保证不会出现循环问题

这样会导致每个元素都被验证
@NotNull
@Valid
private List<Person> passengers = new ArrayList<Person>();

一些标准可用的约束:
http://docs.jboss.org/hibernate/validator/5.2/reference/en-US/html/ch02.html

一些hibernate自定义的约束
http://docs.jboss.org/hibernate/validator/5.2/reference/en-US/html/ch02.html
可以验证邮箱
url
SafeHtml
range, 字符串长度范围

可以对函数的输入参数和返回值做验证

有的时候验证是对多个参数作为整体进行验证, 这种验证叫做 cross parameter 验证
```
@LuggageCountMatchesPassengerCount(piecesOfLuggagePerPassenger = 2)
public void load(List<Person> passengers, List<PieceOfLuggage> luggage) {
//...
}
@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.PARAMETERS)
public Car buildCar(List<Part> parts) {
	//...
}
@ParameterScriptAssert(lang = "javascript", script = "arg1.size() <= arg0.size() * 2")
public void load(List<Person> passengers, List<PieceOfLuggage> luggage) {
	//...
}
```

验证失败的时候, 将会从 ValidationMessages 里获取相应的字符串, 基于MessageBundle, 因此可以进行插值的
在自己classpath下放 ValidationMessages_zh_CN.properties 等 就可以重写错误消息, 可以看看hibernate提供的消息


进行配置
```
Validator validator = Validation.byDefaultProvider()
		.configure()
		.messageInterpolator(
				new ResourceBundleMessageInterpolator(
						new PlatformResourceBundleLocator( "MyMessages" )
				)
		)
		.buildValidatorFactory()
		.getValidator();
```

验证组, 只对属于某一组的属性进行验证, 否则有些场景下某个属性是可以不用验证的!
每个annotation都会有一个属性叫做 groups, 用它可以指定该属性所属于的组
然后你在验证的时候也可以指定要对哪一(些)组的属性进行验证
组是使用 类来表示的, 因此你可能需要创建很多的空接口

默认都会有一组 javax.validation.groups.Default


使用 @GroupSequence 可以指定一系列的组, 这些组会作为默认组
靠前的优先级高

ConvertGroup 用于 指定@Valid验证所需要的组, 默认是 默认组
@Valid
@ConvertGroup(from = Default.class, to = DriverChecks.class)
private Driver driver;
	

# 自定义约束 #

# 复合约束 #
```
相当于是下面3个约束的组合
@NotNull
@Size(min = 2, max = 14)
@CheckCase(CaseMode.UPPER)

@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = { }) 这里要记得设置成{}
@Documented
public @interface ValidLicensePlate {

	String message() default "{org.hibernate.validator.referenceguide.chapter06." +
			"constraintcomposition.ValidLicensePlate.message}";

	Class<?>[] groups() default { };

	Class<? extends Payload>[] payload() default { };
}
```

