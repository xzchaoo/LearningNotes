https://jersey.java.net/documentation/latest/getting-started.html

# 1 #
maven骨架

# 3 #
Path
GET POST PUT DELETE HEAD
Produces
Consumes
QueryParam DefaultValue PathParam
@MatrixParam, @HeaderParam, @CookieParam, @FormParam

In general the Java type of the method parameter may:

Be a primitive type;

Have a constructor that accepts a single String argument;

Have a static method named valueOf or fromString that accepts a single String argument (see, for example, Integer.valueOf(String) and java.util.UUID.fromString(String));

Have a registered implementation of javax.ws.rs.ext.ParamConverterProvider JAX-RS extension SPI that returns a javax.ws.rs.ext.ParamConverter instance capable of a "from string" conversion for the type. or

Be List<T>, Set<T> or SortedSet<T>, where T satisfies 2 or 3 above. The resulting collection is read-only.



@Context UriInfo ui
@Context HttpHeaders hh
@Encoded

另外一种方式:
```
Another kind of injection is the @BeanParam which allows to inject the parameters described above into a single bean. A bean annotated with @BeanParam containing any fields and appropriate *param annotation(like @PathParam) will be initialized with corresponding request values in expected way as if these fields were in the resource class. Then instead of injecting request values like path param into a constructor parameters or class fields the @BeanParam can be used to inject such a bean into a resource or resource method. The @BeanParam is used this way to aggregate more request parameters into a single bean.

Example 3.14. Example of the bean which will be used as @BeanParam

public class MyBeanParam {
    @PathParam("p")
    private String pathParam;
 
    @MatrixParam("m")
    @Encoded
    @DefaultValue("default")
    private String matrixParam;
 
    @HeaderParam("header")
    private String headerParam;
 
    private String queryParam;
 
    public MyBeanParam(@QueryParam("q") String queryParam) {
        this.queryParam = queryParam;
    }
 
    public String getPathParam() {
        return pathParam;
    }
    ...
}

Example 3.15. Injection of MyBeanParam as a method parameter:

@POST
public void post(@BeanParam MyBeanParam beanParam, String entity) {
    final String pathParam = beanParam.getPathParam(); // contains injected path parameter "p"
    ...
}
```

Resource

根类默认每次请求都创建一次(之所以允许每次都创建一个对象, 是因为成员变量也可以使用@QueryParam之类的注解!)

可以使用@Singleton
会延迟到第一次访问才创建
但这就不能注入到成员变量了

但下面这个是允许注入成员变量的
@Context
Request request;

When deploying a JAX-RS application using servlet then ServletConfig, ServletContext, HttpServletRequest and HttpServletResponse are available using @Context.

# 4 #
ResourceConfig 继承了 Application 并且提供了更多的配置


当要启动一些特性的时候, 需要将相应的jar包放早classpath下, 并且需要显式注册他们.
但下面这些包不用显式注册, 只需要放就行
JSON binding feature from jersey-media-moxy
jersey-media-json-processing
jersey-bean-validation
WadlFeature - enables WADL processing.
UriConnegFilter - a URI-based content negotiation filter.

	ResourceConfig resourceConfig = new ResourceConfig(MyResource.class);
	resourceConfig.register(org.glassfish.jersey.server.filter.UriConnegFilter.class);
	resourceConfig.register(org.glassfish.jersey.server.validation.ValidationFeature.class);
	resourceConfig.register(org.glassfish.jersey.server.spring.SpringComponentProvider.class);
	resourceConfig.register(org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpContainerProvider.class);
	resourceConfig.property(ServerProperties.METAINF_SERVICES_LOOKUP_DISABLE, true);

当部署到容器的时候, 可以选择 Servlet 或 Filter 方式

Servlet 3.0 后
```
@ApplicationPath("resources")
public class MyApplication extends ResourceConfig {
    public MyApplication() {
        packages("org.foo.rest;org.bar.rest");
    }
}
```
或
```
    <servlet>
	<!--如果你自己继承了 Application 那么久换成你的类名-->
        <servlet-name>javax.ws.rs.core.Application</servlet-name>
    </servlet>
 
    <servlet-mapping>
        <servlet-name>javax.ws.rs.core.Application</servlet-name>
        <url-pattern>/myresources/*</url-pattern>
    </servlet-mapping>
```

# 5 客户端API #
2.0后才引入

jersey的客户端支持更换底层的http组件(称为 Connector )
比如 HttpURLConnection, apache http client
UriBuilder
UriTemplate

	Client client = ClientBuilder.newClient();
	WebTarget target = client.target("http://localhost:9998").path("resource");
	 
	Form form = new Form();
	form.param("x", "foo");
	form.param("y", "bar");
	 
	MyJAXBBean bean =
	target.request(MediaType.APPLICATION_JSON_TYPE)
	    .post(Entity.entity(form,MediaType.APPLICATION_FORM_URLENCODED_TYPE),
	        MyJAXBBean.class);

配置过滤器

	ClientConfig clientConfig = new ClientConfig();
	clientConfig.register(MyClientResponseFilter.class);
	clientConfig.register(new AnotherClientFilter());
	Client client = ClientBuilder.newClient(clientConfig);

	Client client = ClientBuilder.newClient(new ClientConfig()
        .register(MyClientResponseFilter.class)
        .register(new AnotherClientFilter());
	
	WebTarget webTarget = client.target("http://example.com/rest");
	WebTarget webTarget = client.target("http://example.com/rest");
	webTarget.register(FilterForExampleCom.class);

	WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");
	WebTarget helloworldWebTargetWithQueryParam =
	helloworldWebTarget.queryParam("greeting", "Hi World!");
	
	Invocation.Builder invocationBuilder =
       helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE); 表示 Accept: text/plain
	invocationBuilder.header("some-header", "true");
	
	ClientRequestContext
	ClientRequestFilter

	Response postResponse =
	        helloworldWebTarget.request(MediaType.TEXT_PLAIN_TYPE)
	                .post(Entity.entity("A string entity to be POSTed", MediaType.TEXT_PLAIN)); 


```
ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());
 
Client client = ClientBuilder.newClient(clientConfig);
client.register(ThirdClientFilter.class);
 
WebTarget webTarget = client.target("http://example.com/rest");
webTarget.register(FilterForExampleCom.class);
WebTarget resourceWebTarget = webTarget.path("resource");
WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");
WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!");
 
Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);
invocationBuilder.header("some-header", "true");
 
Response response = invocationBuilder.get();
System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));
```

流式API
```
Client client = ClientBuilder.newClient(new ClientConfig()
            .register(MyClientResponseFilter.class)
            .register(new AnotherClientFilter()));
 
String entity = client.target("http://example.com/rest")
            .register(FilterForExampleCom.class)
            .path("resource/helloworld")
            .queryParam("greeting", "Hi World!")
            .request(MediaType.TEXT_PLAIN_TYPE)
            .header("some-header", "true")
            .get(String.class);
```

InputStream in = response.readEntity(InputStream.class);
File

MessageBodyReader<T> and MessageBodyWriter<T>
Classes or implementations of the provider-based interfaces need to be registered as providers within the JAX-RS or Jersey Client API components that implement Configurable contract (ClientBuilder, Client, WebTarget or ClientConfig), as was shown in the earlier sections. Some media types are provided in the form of JAX-RS Feature a concept that allows the extension providers to group together multiple different extension providers and/or configuration properties in order to simplify the registration and configuration of the provided feature by the end users. For example, MoxyJsonFeature can be register to enable and configure JSON binding support via MOXy library.


Connectors
https://jersey.java.net/apidocs/2.22.2/jersey/org/glassfish/jersey/client/spi/Connector.html

ClientConfig clientConfig = new ClientConfig();
clientConfig.connectorProvider(new GrizzlyConnectorProvider());
Client client = ClientBuilder.newClient(clientConfig);

在Entity被读取完毕之后, 底层的连接就被关闭了

```
public static class MyRequestFilter implements ClientRequestFilter {
    // this injection does not work as filter is registered as an instance:
    // @Inject
    // private MyInjectedService service;
 
    @Override
    public void filter(ClientRequestContext requestContext) throws IOException {
        // use ServiceLocatorClientProvider to extract HK2 ServiceLocator from request
        final ServiceLocator locator = ServiceLocatorClientProvider.getServiceLocator(requestContext);
 
        // and ask for MyInjectedService:
        final MyInjectedService service = locator.getService(MyInjectedService.class);
 
        final String name = service.getName();
        ...
    }
}
```

安全
SslConfigurator sslConfig = SslConfigurator.newInstance()
        .trustStoreFile("./truststore_client")
        .trustStorePassword("secret-password-for-truststore")
        .keyStoreFile("./keystore_client")
        .keyPassword("secret-password-for-keystore");
 
SSLContext sslContext = sslConfig.createSSLContext();
Client client = ClientBuilder.newBuilder().sslContext(sslContext).build();

认证
```
HttpAuthenticationFeature feature = HttpAuthenticationFeature.basic("user", "superSecretPassword");

HttpAuthenticationFeature feature = HttpAuthenticationFeature.basicBuilder()
    .nonPreemptive().credentials("user", "superSecretPassword").build();

HttpAuthenticationFeature feature = HttpAuthenticationFeature.basicBuilder().build();

Response response = client.target("http://localhost:8080/rest/homer/contact").request()
    .property(HTTP_AUTHENTICATION_BASIC_USERNAME, "homer")
    .property(HTTP_AUTHENTICATION_BASIC_PASSWORD, "p1swd745").get();
```

# 6 #
```
List<Destination> recommended = Collections.emptyList();
try {
    recommended = destination.path("recommended").request()
            // Identify the user.
            .header("Rx-User", "Sync")
            // Return a list of destinations.
            .get(new GenericType<List<Destination>>() {});
```


CountDownLatch

RxClient<RxObservableInvoker> rxClient = Rx.from(client, RxObservableInvoker.class);
RxClient<RxObservableInvoker> rxClient = RxObservable.from(client);

# 7 #
return Response.ok(f, mt).build();
异常类可以继承 WebApplicationException 
然后可以配置当抛出这个异常时的状态码
	
	public class CustomNotFoundException extends WebApplicationException {
	 
	  /**
	  * Create a HTTP 404 (Not Found) exception.
	  */
	  public CustomNotFoundException() {
	    super(Responses.notFound().build());
	  }
	 
	  /**
	  * Create a HTTP 404 (Not Found) exception.
	  * @param message the String that is the entity of the 404 response.
	  */
	  public CustomNotFoundException(String message) {
	    super(Response.status(Responses.NOT_FOUND).
	    entity(message).type("text/plain").build());
	  }
	}

	@Provider
	public class EntityNotFoundMapper implements ExceptionMapper<javax.persistence.EntityNotFoundException> {
	  public Response toResponse(javax.persistence.EntityNotFoundException ex) {
	    return Response.status(404).
	      entity(ex.getMessage()).
	      type("text/plain").
	      build();
	  }
	}

https://jersey.java.net/documentation/latest/representations.html
这里有一个教程可以返回304

# 9 json #
1. MOXy - JSON binding support via MOXy is a default and preferred way of supporting JSON binding in your Jersey applications since Jersey 2.0. When JSON MOXy module is on the class-path, Jersey will automatically discover the module and seamlessly enable JSON binding support via MOXy in your applications. (See Section 4.3, “Auto-Discoverable Features”.)
2. Java API for JSON Processing (JSON-P)
3. Jackson
4. Jettison

- POJO based JSON binding support
- JAXB based JSON binding support, 使用XML的annotation, 它们也可以用于定制json
- Low-level JSON parsing & processing support

当然也可以通过 JSON-P 的低级API来手动处理json

	JsonObject myObject = Json.createObjectBuilder()
	        .add("name", "Agamemnon")
	        .add("age", 32)
	        .build();
	JSONObject myObject = new JSONObject();
	try {
	    myObject.put("name", "Agamemnon");
	    myObject.put("age", 32);
	} catch (JSONException ex) {
	    LOGGER.log(Level.SEVERE, "Error ...", ex);
	}

MOXy
<dependency>
    <groupId>org.glassfish.jersey.media</groupId>
    <artifactId>jersey-media-moxy</artifactId>
    <version>2.22.2</version>
</dependency>
MOXy模块是特殊的, 只要放在classpath下, 就自动生效

@JSONP
@JSONP(callback = "eval", queryParam = "jsonpCallback")

## XML ##
低级XML支持
```
@POST
@Path("StreamSource")
public StreamSource getStreamSource(StreamSource streamSource) {
    return streamSource;
}
 
@POST
@Path("SAXSource")
public SAXSource getSAXSource(SAXSource saxSource) {
    return saxSource;
}
 
@POST
@Path("DOMSource")
public DOMSource getDOMSource(DOMSource domSource) {
    return domSource;
}
 
@POST
@Path("Document")
public Document getDocument(Document document) {
    return document;
}
```


# 10 过滤器/拦截器 #
```
public class AuthorizationRequestFilter implements ContainerRequestFilter {
 
    @Override
    public void filter(ContainerRequestContext requestContext)
                    throws IOException {
 
        final SecurityContext securityContext =
                    requestContext.getSecurityContext();
        if (securityContext == null ||
                    !securityContext.isUserInRole("privileged")) {
 
                requestContext.abortWith(Response
                    .status(Response.Status.UNAUTHORIZED)
                    .entity("User cannot access the resource.")
                    .build());
        }
    }
}
```

需要用register后才会生效

过滤器
Container Request/Response Filter
Client Request/Response Filter

拦截器 也是服务端和客户端都有的
ReaderInterceptor 
WriterInterceptor
拦截器的话只要是可以对 Stream 做操作
因此可以进行GZIP压缩

一般执行顺序是 filter, interceptor, reader/writer



```
public class GZIPReaderInterceptor implements ReaderInterceptor {
 
    @Override
    public Object aroundReadFrom(ReaderInterceptorContext context)
                    throws IOException, WebApplicationException {
        final InputStream originalInputStream = context.getInputStream();
        context.setInputStream(new GZIPInputStream(originalInputStream));
        return context.proceed();
    }
}
```




@PreMatching
As written above, pre-matching filters can fully influence the request matching process, which means you can even modify request URI in a pre-matching filter by invoking the setRequestUri(URI) method of ContainerRequestFilter so that a different resource would be matched.


## 命名绑定 ##
```
// @Compress annotation is the name binding annotation
@NameBinding
@Retention(RetentionPolicy.RUNTIME)
public @interface Compress {}
 
 
@Path("helloworld")
public class HelloWorldResource {
 
    @GET
    @Produces("text/plain")
    public String getHello() {
        return "Hello World!";
    }
 
    @GET
    @Path("too-much-data")
    @Compress
    public String getVeryLongString() {
        String str = ... // very long string
        return str;
    }
}
 
// interceptor will be executed only when resource methods
// annotated with @Compress annotation will be executed
@Compress
public class GZIPWriterInterceptor implements WriterInterceptor {
    @Override
    public void aroundWriteTo(WriterInterceptorContext context)
                    throws IOException, WebApplicationException {
        final OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(new GZIPOutputStream(outputStream));
        context.proceed();
    }
}
```
这样的话 @Compress 对应的拦截器就自动运用到相应的方法上

优先级
@Priority(Priorities.HEADER_DECORATOR)
越低越早执行

# 11. 异步 #
## 服务端 ##
异步处理并不会缩短延迟, 一般是会提高服务端的吞吐量
```
 @GET
    public void asyncGet(@Suspended final AsyncResponse asyncResponse) {
 
        new Thread(new Runnable() {
            @Override
            public void run() {
                String result = veryExpensiveOperation();
                asyncResponse.resume(result);
            }
 
            private String veryExpensiveOperation() {
                // ... very expensive operation
            }
        }).start();
    }
```
用@ Suspended 注入  AsyncResponse 对象
然后自己起一个线程去处理, 处理完后调用 resume
可以设置超时时间和超时处理器

回调
asyncResp.register(new CompletionCallback(){...})

ConnectionCallback

```
@Path("/resource")
public class AsyncResource {
    @GET
    public ChunkedOutput<String> getChunkedResponse() {
        final ChunkedOutput<String> output = new ChunkedOutput<String>(String.class);
 
        new Thread() {
            public void run() {
                try {
                    String chunk;
 
                    while ((chunk = getNextString()) != null) {
                        output.write(chunk);
                    }
                } catch (IOException e) {
                    // IOException thrown when writing the
                    // chunks of response: should be handled
                } finally {
                    output.close();
                        // simplified: IOException thrown from
                        // this close() should be handled here...
                }
            }
        }.start();
 
        // the output will be probably returned even before
        // a first chunk is written by the new thread
        return output;
    }
 
    private String getNextString() {
        // ... long running operation that returns
        //     next string or null if no other string is accessible
    }
}
```



## 客户端 ##
如果要异步的话, 简单场景下使用Future, 复杂一点就使用Rxjava

```
final Response response = target().path("http://example.com/resource/")
        .request().get();
final ChunkedInput<String> chunkedInput =
        response.readEntity(new GenericType<ChunkedInput<String>>() {});
String chunk;
while ((chunk = chunkedInput.read()) != null) {
    System.out.println("Next chunk received: " + chunk);
}
```

# 12 URI , Links #
@Context UriInfo uriInfo;
UriBuilder
```
UriBuilder.fromUri("http://localhost/")
    .path("{a}")
    .queryParam("name", "{value}")
    .build("segment", "value");
```

```
Response r = Response.ok().
    link("http://oracle.com", "parent").
    link(new URI("http://jersey.java.net"), "framework").
    build();
```

# 15 SSE支持 #
Server Send Event
```
@Path("events")
public static class SseResource {
 
    @GET
    @Produces(SseFeature.SERVER_SENT_EVENTS)
    public EventOutput getServerSentEvents() {
        final EventOutput eventOutput = new EventOutput();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    for (int i = 0; i < 10; i++) {
                        // ... code that waits 1 second
                        final OutboundEvent.Builder eventBuilder
                        = new OutboundEvent.Builder();
                        eventBuilder.name("message-to-client");
                        eventBuilder.data(String.class,
                            "Hello world " + i + "!");
                        final OutboundEvent event = eventBuilder.build();
                        eventOutput.write(event);
                    }
                } catch (IOException e) {
                    throw new RuntimeException(
                        "Error when writing the event.", e);
                } finally {
                    try {
                        eventOutput.close();
                    } catch (IOException ioClose) {
                        throw new RuntimeException(
                            "Error when closing the event output.", ioClose);
                    }
                }
            }
        }).start();
        return eventOutput;
    }
}

```
# 16 安全 #
@Context SecurityContext sc;

# 18 bean验证 #
```
<dependency>
    <groupId>org.glassfish.jersey.ext</groupId>
    <artifactId>jersey-bean-validation</artifactId>
    <version>2.22.2</version>
</dependency>
```


ValidationFeature是一个可以自动注册的Feature

ValidationConfig

ServerProperties.BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK
@ValidateOnExecution

ServerProperties.BV_SEND_ERROR_IN_RESPONSE
Enables sending validation errors in response entity to the client. More on this in Section 18.7.1, “ValidationError”.


ContextResolver

```
@Path("/")
class MyResourceClass {
 
    @POST
    @Consumes("application/x-www-form-urlencoded")
    public void registerUser(
            @NotNull @FormParam("firstName") String firstName,
            @NotNull @FormParam("lastName") String lastName,
            @Email @FormParam("email") String email) {
        ...
    }
}
```

当违反 @Email 约束的时候就会返回400
使用 @Valid 可以对注入的对象进行验证

方法的返回值也可以被验证:
```
@GET
@Path("{id}")
@Produces("application/xml")
@Valid @PremiumUser
public User getUser(@PathParam("id") String id) {
    User u = findUser(id);
    return u;
}
```

```
@Path("/")
class MyResourceClass {
 
    @Email
    @ValidateOnExecution
    public String getEmail() {
        return email;
    }
 
    ...
}
```

@Context private UriInfo uriInfo; 可以注入到 ConstraintValidator 里

启动 EntityFilteringFeature
Filtering based on entity-filtering annotations (or i.e. external configuration file) created using @EntityFiltering meta-annotation.

SelectableEntityFilteringFeature
Filtering based on dynamic and configurable query parameters.

Entity-filtering currently recognizes one property that can be passed into the Configuration instance (client/server):

EntityFilteringFeature.ENTITY_FILTERING_SCOPE - "jersey.config.entityFiltering.scope"

Defines one or more annotations that should be used as entity-filtering scope when reading/writing an entity.

Note

Processing of entity-filtering annotations to create an entity-filtering scope is defined by following: "Request/Resource entity annotations" > "Configuration" > "Resource method/class annotations" (on server).



@XmlRootElement
public class Address {
 
    private String streetAddress;
 
    private String region;
 
    private PhoneNumber phoneNumber;
}
/addresses/51234?select=region,streetAddress 只会返回这几个属性
{
   "region" : "CA",
   "streetAddress" : "1234 Fake St."
}

