1. 可以帮助你快速开发一个基于Spring的简单应用
2. 当然我认为这是简单的, 比如你想要对Spring的功能做测试, 它就可以帮你快速搭建出一个简单的环境
3. 可以帮你把所有包打在一起, 让你可以 java -jar 直接运行, 比如内嵌tomcat


@EnableAutoConfiguration

运行
mvn spring-boot:run


# 打成一个jar #
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
然后执行 mvn package, java -jar 生成的jar文件 就可以独立运行了!
仔细查看生成的jar文件的META-INF里的清单文件的MainClass定义
实际上是这个插件会在生成的jar文件里织入一些逻辑, 使得其他的jar包可以被打包到一起



<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.3.3.RELEASE</version>
</parent>
这个parent会带来很多的默认配置


# 你可以通过下面的方式重写依赖的版本 #
<properties>
    <spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
</properties>
可以跟入到 spring-boot-dependencies 的pom文件里去就可以看到很多的版本号配置


如果不用parent, 也可以手动导入:
<dependencyManagement>
     <dependencies>
        <dependency>
            <!-- Import dependency management from Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.3.3.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
这种情况下你如果想重写版本, 要这样:
```
<dependencyManagement>
    <dependencies>
        <!-- Override Spring Data release train provided by Spring Boot -->
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-releasetrain</artifactId>
            <version>Fowler-SR2</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.3.3.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```
<properties>
    <java.version>1.8</java.version>
</properties>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>

@ComponentScan, @EntityScan
@SpringBootApplication = configuration + enableauth... + componentscan

@EnableAutoConfiguration 会根据你的jar文件进行一些默认的配置, 比如发现你有jdbc, 就自动帮你配置一个 内嵌的数据源, 这个行为有的时候可能不是我们想要的
又比如检测到你导入了springmvc的配置, 就自动帮你启动MVC功能了
可以使用exclude属性或spring.autoconfigure.exclude 来排除

@Configuration 该类是一个配置类
@Import 导入其他的配置类
@ImportResource 导入其他的配置文件(applicationContext.xml)
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}

依赖注入相关
@Component @Service @Reposiroty @Controller
@ComponenetScan @Autowired @Inject @Resource


application.properties

2 个对象勺子和叉子 用原型模式可克隆出来
勺子需要在原型管理器来管理 用通常方法管理
工厂类它是重量级的 他必须是单例的
勺子和叉子会有若干种 用抽象工厂来实现这一对勺子和叉子
通过Builder模式向用户提供勺子和叉子的套装


# 热替换 #
导入下面的依赖就行了, 其他什么也不用做
```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-devtools</artifactId>
	<optional>true</optional>
</dependency>
```
把它设置成optional就可以防止他被最终打包


# 20 属性 #
在resources目录下放 application.properties, 然后配置一些属性


@Value("${name}")
private String name;


## 排除导致reload的资源 ##
默认情况下 /resources /static /public /templates 等目录下的文件的修改不会触发 reload 操作
可以通过 spring.devtools.restart.exclude=static/**,public/** 来修改
或使用 spring.devtools.restart.additional-exclude 来添加额外的不会导致 reload 的资源路径

## 启动参数 ##
java -jar -Dceshi=a 就可以收到参数
然后使用

	@Autowired
	ApplicationArguments args;
注入就可以得到参数们

@Profile
spring.profiles.active=dev,hsqldb

看到25.

# 23 #
banner中有一些变量是可以插值的

SpringApplicationBuilder
1. 一些时间的监听
2. 

# 24. 外部配置 #
文档这里列出了一堆支持的配置信息的来源

同样支持yaml文件
application-{profile}.properties
application.properties
@PropertySource annotations on your @Configuration classes.

```
@Value("${name}")
private String name;
```

@Value 似乎处理不了数组问题, 比如
nums=1,2,3
@Value("${nums}")
List<Integer> nums; 它是处理不了的

java -jar app.jar --name="Spring"

在 src/main/resources/config/ 下放一个 application-ceshi.properties
里面写了 author = xzchaoo
```
ConfigurableApplicationContext ctx = new SpringApplicationBuilder( AppMain.class )
		.profiles( "ceshi" ) //可以激活多个profile 默认是会激活 application.properties
		.build()
		.run( args );
UserService us = ctx.getBean( UserService.class );
System.out.println( us.getAuthor() );
ctx.close();
```
这样得到的结果就是 xzchaoo

这样是OK的
```
app.name=MyApp
app.description=${app.name} is a Spring Boot application
```

似乎yawl里不能放 tab键

可以将一个配置文件直接转换成一个对象
并且支持数组处理!

```
@ConfigurationProperties(prefix="my") 可以和 BeanValidation 之类的一起使用
public class Config {
    private List<String> servers = new ArrayList<String>();
    public List<String> getServers() {
        return this.servers;
    }
}
```

@PropertySources({
	@PropertySource("classpath:ps.properties")
})

对注入的值可以使用 @NotNull @NotEmpty 等annotation 进行验证

## 第三方配置 ##
```
@ConfigurationProperties(prefix = "foo")
@Bean
public FooComponent fooComponent() {
    ...
}
```

# 25. Profiles #
属性 spring.profiles.active=dev,hsqldb
启动参数 --spring.profiles.active=dev,hsqldb


指定全局的profiles
```
ConfigurableApplicationContext ctx = new SpringApplicationBuilder( AppMain.class )
		.profiles( "ceshi" )
		.build()
		.run( args );
```

@Profile("production")
可以放在某个的单独的类上, 这样这个类就会使用它指定的profile 而不是全局的profile
spring.profiles: prod
spring.profiles.include: proddb,prodmq

# 26. Logging #
默认使用 commons-logging

在 application.properties 中设置debug=true 可以让log的等级为debug

配置日志的格式 和 颜色(如果支持的话)

使用其他的日志库

使用 logging.file 或 logging.path 可以控制日志输出到文件

控制日志级别
logging.level.root=WARN
logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate=ERROR


# 27. WEB #
1. 依赖 spring-boot-starter-web 模块
2. 直接就可以开始写你的controller了

然后它自己启动了一堆东西
27.1.1 Spring MVC auto-configuration

可以自己在写一个类, 带有@Configuration  @EnableWebMvc, 这样就可以完全配置你的mvc了

不习惯这样的开发方式怎么办!


# 29 数据库 #
添加依赖
```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```
它会自动引入一些东西, 包括 tomcat-jdbc

在 application.properties 里配置:
```
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/d1
username=root
password=123456
```
更多的配置可以去看 DataSourceProperties 这个类

并且会自动注册一个 JdbcTemplate  和 NamedParameterJdbcTemplate



# 参数配置 #
@ConfigurationProperties(prefix = "db", locations = "file:db.properties")
@Bean
public DataSource dataSource() {
	org.apache.tomcat.jdbc.pool.DataSource ds = new org.apache.tomcat.jdbc.pool.DataSource();
	return ds;
}

通过 PropertySource 添加的属性的优先级比较低
Properties added in this way have lower priority than any added using the default locations (e.g. application.properties), system properties, environment variables or the command line.

@PropertySource < application.properties < 系统属性 < 命令行参数

1. 通过命令行指定 --author=xx
2. 指定系统属性 -Dauthor=x
3. application.properties 里 author=xzc
4. 通过 PropertySource 引入一个 author=xzchaoo

最高的是 xx, 然后是x, 然后是xzc, 最后是xzchaoo

按照上面的方法, 如果你要指定 server.port 的话, 你需要
--server.port=8080 这样显得有点麻烦, 特别是当你的key比较长的时候
可以在配置文件里这样
server.port=${port:8080}
然后通过命令行参数 --port=9090

支持yaml文件


设置激活的profiles
通过 spring.profiles.active 属性
因此你可以在上面提到的4个地方设置这个属性

比如通过命令行
java -jar -Dspring.profiles.active=production demo-0.0.1-SNAPSHOT.jar

不同profile下的配置
application-${profile}.properties


如果想在打包之后, 让用户修改一些配置参数怎么办?
按照上面的说法, 就是要通过命令行或系统属性, 如果属性比较多的话, 你可能要考虑写一个启动脚本来处理会比较好

其实也可以使用 @PropertySource, 它可以接受 file:abc.properties 而这个文件是相对于 java -jar ... 的当前路径的
但是要注意 @PropertySource 的优先级比较低, 因此他用到的属性必须不能出现在比它高级的 属性里, 否则它肯定被覆盖


```
//后面的属性文件会覆盖前面的属性
@PropertySources({
	@PropertySource(value = {"classpath:xzc.properties"}, ignoreResourceNotFound = false),
	@PropertySource(value = {"file:app.properties"}, ignoreResourceNotFound = true)
})
```
第一个 classpath:xzc.properties 提供了默认配置
第二个 file:app.properties 提供了用户覆盖配置的机会, 只要在它的当前运行目录下有 app.properties 就可以进行覆盖

