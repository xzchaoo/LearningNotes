1. 可以帮助你快速开发一个基于Spring的简单应用
2. 当然我认为这是简单的, 比如你想要对Spring的功能做测试, 它就可以帮你快速搭建出一个简单的环境
3. 可以帮你把所有包打在一起, 让你可以 java -jar 直接运行, 比如内嵌tomcat


@EnableAutoConfiguration

执行起点:
mvn spring-boot:run


打成一个jar
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>


<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.3.3.RELEASE</version>
</parent>
这个parent会带来很多的默认配置

你可以通过下面的方式重写依赖的版本
<properties>
    <spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
</properties>

如果不用parent, 也可以手动导入:
<dependencyManagement>
     <dependencies>
        <dependency>
            <!-- Import dependency management from Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.3.3.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
这种情况下你如果想重写版本, 要这样:
```
<dependencyManagement>
    <dependencies>
        <!-- Override Spring Data release train provided by Spring Boot -->
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-releasetrain</artifactId>
            <version>Fowler-SR2</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.3.3.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```
<properties>
    <java.version>1.8</java.version>
</properties>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>

@ComponentScan, @EntityScan
@SpringBootApplication = configuration + enableauth... + componentscan

@EnableAutoConfiguration 启动Spring的自动配置, Spring会根据你classpath下的jar, 推测你需要的配置!
@Configuration @Import 
@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}


application.properties

2 个对象勺子和叉子 用原型模式可克隆出来
勺子需要在原型管理器来管理 用通常方法管理
工厂类它是重量级的 他必须是单例的
勺子和叉子会有若干种 用抽象工厂来实现这一对勺子和叉子
通过Builder模式向用户提供勺子和叉子的套装


@Value("${name}")
private String name;

@Profile
spring.profiles.active=dev,hsqldb

看到25.

# 23 #
banner中有一些变量是可以插值的

SpringApplicationBuilder
1. 一些时间的监听
2. 

# 24. 外部配置 #
同样支持yaml文件
application-{profile}.properties
application.properties
@PropertySource annotations on your @Configuration classes.

```
@Value("${name}")
private String name;
```

java -jar app.jar --name="Spring"

在 src/main/resources/config/ 下放一个 application-ceshi.properties
里面写了 author = xzchaoo
```
ConfigurableApplicationContext ctx = new SpringApplicationBuilder( AppMain.class )
		.profiles( "ceshi" ) //可以激活多个profile 默认是会激活 application.properties
		.build()
		.run( args );
UserService us = ctx.getBean( UserService.class );
System.out.println( us.getAuthor() );
ctx.close();
```
这样得到的结果就是 xzchaoo

这样是OK的
```
app.name=MyApp
app.description=${app.name} is a Spring Boot application
```

似乎yawl里不能放 tab键

可以将一个配置文件直接转换成一个对象
```
@ConfigurationProperties(prefix="my")
public class Config {
    private List<String> servers = new ArrayList<String>();
    public List<String> getServers() {
        return this.servers;
    }
}
```

@PropertySources({
	@PropertySource("classpath:ps.properties")
})

@ConfigurationProperties(prefix = "foo")还可以放在某个方法上, 这样会对放回的值进行注值

对注入的值可以使用 @NotNull @NotEmpty 等annotation 进行验证

# 25. Profiles #
指定全局的profiles
```
ConfigurableApplicationContext ctx = new SpringApplicationBuilder( AppMain.class )
		.profiles( "ceshi" )
		.build()
		.run( args );
```

@Profile("production")
可以放在某个的单独的类上, 这样这个类就会使用它指定的profile 而不是全局的profile

# 26. Logging #
默认使用 commons-logging

在 application.properties 中设置debug=true 可以让log的等级为debug

配置日志的格式 和 颜色(如果支持的话)

使用其他的日志库

# 27. WEB #
1. 依赖 spring-boot-starter-web 模块
2. 直接就可以开始写你的controller了

然后它自己启动了一堆东西
27.1.1 Spring MVC auto-configuration

可以自己在写一个类, 带有@Configuration  @EnableWebMvc, 这样就可以完全配置你的mvc了

不习惯这样的开发方式怎么办!