1. 可以帮助你快速开发一个基于Spring的简单应用
2. 当然我认为这是简单的, 比如你想要对Spring的功能做测试, 它就可以帮你快速搭建出一个简单的环境
3. 可以帮你把所有包打在一起, 让你可以 java -jar 直接运行, 比如内嵌tomcat


@EnableAutoConfiguration

运行
mvn spring-boot:run


# 打成一个jar #
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
然后执行 mvn package, java -jar 生成的jar文件 就可以独立运行了!
仔细查看生成的jar文件的META-INF里的清单文件的MainClass定义
实际上是这个插件会在生成的jar文件里织入一些逻辑, 使得其他的jar包可以被打包到一起



<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.3.3.RELEASE</version>
</parent>
这个parent会带来很多的默认配置


# 你可以通过下面的方式重写依赖的版本 #
<properties>
    <spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
</properties>
可以跟入到 spring-boot-dependencies 的pom文件里去就可以看到很多的版本号配置


如果不用parent, 也可以手动导入:
<dependencyManagement>
     <dependencies>
        <dependency>
            <!-- Import dependency management from Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.3.3.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
这种情况下你如果想重写版本, 要这样:
```
<dependencyManagement>
    <dependencies>
        <!-- Override Spring Data release train provided by Spring Boot -->
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-releasetrain</artifactId>
            <version>Fowler-SR2</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>1.3.3.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```
<properties>
    <java.version>1.8</java.version>
</properties>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>

@ComponentScan, @EntityScan
@SpringBootApplication = configuration + enableauth... + componentscan

@EnableAutoConfiguration 会根据你的jar文件进行一些默认的配置, 比如发现你有jdbc, 就自动帮你配置一个 内嵌的数据源, 这个行为有的时候可能不是我们想要的
又比如检测到你导入了springmvc的配置, 就自动帮你启动MVC功能了
可以使用exclude属性或spring.autoconfigure.exclude 来排除

@Configuration 该类是一个配置类
@Import 导入其他的配置类
@ImportResource 导入其他的配置文件(applicationContext.xml)
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}

依赖注入相关
@Component @Service @Reposiroty @Controller
@ComponenetScan @Autowired @Inject @Resource


application.properties

2 个对象勺子和叉子 用原型模式可克隆出来
勺子需要在原型管理器来管理 用通常方法管理
工厂类它是重量级的 他必须是单例的
勺子和叉子会有若干种 用抽象工厂来实现这一对勺子和叉子
通过Builder模式向用户提供勺子和叉子的套装


# 热替换 #
导入下面的依赖就行了, 其他什么也不用做
```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-devtools</artifactId>
	<optional>true</optional>
</dependency>
```
把它设置成optional就可以防止他被最终打包


# 20 属性 #
在resources目录下放 application.properties, 然后配置一些属性


@Value("${name}")
private String name;


## 排除导致reload的资源 ##
默认情况下 /resources /static /public /templates 等目录下的文件的修改不会触发 reload 操作
可以通过 spring.devtools.restart.exclude=static/**,public/** 来修改
或使用 spring.devtools.restart.additional-exclude 来添加额外的不会导致 reload 的资源路径

## 启动参数 ##
java -jar -Dceshi=a 就可以收到参数
然后使用

	@Autowired
	ApplicationArguments args;
注入就可以得到参数们

@Profile
spring.profiles.active=dev,hsqldb

看到25.

# 23 #
banner中有一些变量是可以插值的

SpringApplicationBuilder
1. 一些时间的监听
2. 

# 24. 外部配置 #
文档这里列出了一堆支持的配置信息的来源

同样支持yaml文件
application-{profile}.properties
application.properties
@PropertySource annotations on your @Configuration classes.

```
@Value("${name}")
private String name;
```

@Value 似乎处理不了数组问题, 比如
nums=1,2,3
@Value("${nums}")
List<Integer> nums; 它是处理不了的

java -jar app.jar --name="Spring"

在 src/main/resources/config/ 下放一个 application-ceshi.properties
里面写了 author = xzchaoo
```
ConfigurableApplicationContext ctx = new SpringApplicationBuilder( AppMain.class )
		.profiles( "ceshi" ) //可以激活多个profile 默认是会激活 application.properties
		.build()
		.run( args );
UserService us = ctx.getBean( UserService.class );
System.out.println( us.getAuthor() );
ctx.close();
```
这样得到的结果就是 xzchaoo

这样是OK的
```
app.name=MyApp
app.description=${app.name} is a Spring Boot application
```

似乎yawl里不能放 tab键

可以将一个配置文件直接转换成一个对象
并且支持数组处理!

```
@ConfigurationProperties(prefix="my") 可以和 BeanValidation 之类的一起使用
public class Config {
    private List<String> servers = new ArrayList<String>();
    public List<String> getServers() {
        return this.servers;
    }
}
```

@PropertySources({
	@PropertySource("classpath:ps.properties")
})

对注入的值可以使用 @NotNull @NotEmpty 等annotation 进行验证

## 第三方配置 ##
```
@ConfigurationProperties(prefix = "foo")
@Bean
public FooComponent fooComponent() {
    ...
}
```

# 25. Profiles #
属性 spring.profiles.active=dev,hsqldb
启动参数 --spring.profiles.active=dev,hsqldb


指定全局的profiles
```
ConfigurableApplicationContext ctx = new SpringApplicationBuilder( AppMain.class )
		.profiles( "ceshi" )
		.build()
		.run( args );
```

@Profile("production")
可以放在某个的单独的类上, 这样这个类就会使用它指定的profile 而不是全局的profile
spring.profiles: prod
spring.profiles.include: proddb,prodmq

# 26. Logging #
默认使用 commons-logging

在 application.properties 中设置debug=true 可以让log的等级为debug

配置日志的格式 和 颜色(如果支持的话)

使用其他的日志库

使用 logging.file 或 logging.path 可以控制日志输出到文件

控制日志级别
logging.level.root=WARN
logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate=ERROR


# 27. WEB #
1. 依赖 spring-boot-starter-web 模块
2. 直接就可以开始写你的controller了

然后它自己启动了一堆东西
27.1.1 Spring MVC auto-configuration

可以自己在写一个类, 带有@Configuration  @EnableWebMvc, 这样就可以完全配置你的mvc了

不习惯这样的开发方式怎么办!