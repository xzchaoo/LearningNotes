# 几个概念 #
## Aspect ##
一个横切的的模块

## JoinPoint ##
连接点, 可以织入逻辑的点

## Advice ##
通知/增强
before
afterReturning
afterThrowing
after
around

## Poincut ##
用于匹配切入点的过滤器
@Pointcut("execution(public void org.xzc.learn.spring.aop.Singer.sing())")
private void sing() {
}
其他常见的 pointcut 类型

要注意它们匹配的是类还是方法!!!

execution(方法签名) 匹配方法签名
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
            throws-pattern?)

within(类名) 只有当调用的时候是在该类上才会触发
this
target(类名) 当target是目标类的时候才会触发
args(参数名列表) 匹配参数名列表
@target 跟上面的类似, 就是换成annotation版本
@args
@within
@annotation
bean(bean名)

支持 && || ! 括号

within("com.xyz.someapp.service..*")
execution(* com.xyz.someapp..service.*.*(..)
execution(* set*(..))
execution(* com.xyz.service..*.*(..))
target(com.xyz.service.AccountService)
@target(org.springframework.transaction.annotation.Transactional)


execution上的函数参数是静态判断的
而args里的参数是动态判断的

用 .. 或 * 可以匹配多个函数参数

## Introduction ##

## target ##

## AOP Proxy ##

## Weaving ##

# 使用方法 #
1. 加入jar包 rt 和 weaver
2. @EnableAspectJAutoProxy 或 <aop:aspectj-autoproxy/>
3. 对你的Aspect类, 要 @Component @Aspect 两个标记都要

# 事务例子 #
```
<aop:config>
    <aop:advisor
        pointcut="com.xyz.someapp.SystemArchitecture.businessService()"
        advice-ref="tx-advice"/>
</aop:config>

<tx:advice id="tx-advice">
    <tx:attributes>
        <tx:method name="*" propagation="REQUIRED"/>
    </tx:attributes>
</tx:advice>
```

# 方法引入 #
```
@DeclareParents(value = "org.xzc.learn.spring.aop.SingerImpl", defaultImpl = DefaultWorkerImpl.class)
public static Worker workerMixin;
```

# AOP代理 #
AopContext.currentProxy()
