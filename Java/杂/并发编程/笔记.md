# Semaphore #
将会产生n个信号量, 每次调用acquire 默认会消耗一个信号量, 如果没有信号量就会阻塞到有 调用relaese则默认释放一个信号量
可以通过构造函数指定初始化的信号量数量

acquire 阻塞版本
tryAcquire 非阻塞版
acquireUninterruptibly 阻塞摒弃而不会被打断
availablePermits() 当前可用的数量
drainPermits() 立即消耗掉剩余的所有信号量 返回获得的个数
getQueueLength() 返回正在等待这个信号量的线程数量的一个估计值
hasQueuedThreads() 是否有正在等待的线程

信号量初始化的时候可以选择是否是公平, 公平的话就是先到先得, 否则的话只是在概率上保证公平而已

信号量只能保证最多有n个线程可以同时操作一些数据, 并不能保证线程安全.
比如, 假设你有100个线程同时访问一个变量, 那么你的这个变量就面临了100个线程的并发访问.
如果你用一个信号量来保护这个变量, 比如信号量的大小是5, 那么最多只有5个线程可以对这个变量进行并发访问
并发访问依旧存在, 并不能保证线程安全

# Exchanger #
用于两个线程交换数据
线程1 调用 exchange 方法 并且传入一个参数 这个方法会一直阻塞到 线程2也调用exchange方法 传入一个参数, 然后双方就会立即返回 得到的返回值是对方提供的参数

# CountDownlatch #
需要一个初始值来初始化一个计数器, 一些线程调用 countDown 方法 降低这个计数器的值
其他线程对它调用 await 方法 当这个计数器降为0的时候, 它们就会返回
可以用于这样 当所有的运动员都完成比赛的时候 裁判说一声 "所有运动员都完成比赛了" 这样的场景.

# CyclicBarrier #
它允许一组线程相互等待 直到到达某个公共屏障点
当n个线程都调用了 await 方法之后才会立即返回

当线程数量大于n的时候, 可以达到这样一个效果: 一旦调用await的方法数量达到n, 那么这n个阻塞的线程就立即返回继续执行.
即 n个线程 执行一波.

另外 CB 规定,如果一个线程进入了阻塞状态, 但是却由于某种原因提前离开了障碍点, 那么其他的线程都会抛出BrokenBarrierException 或 InterruptedException

CB的几个缺点:
1. 调用一次仅仅消耗一个数量, 不能像信号量那样可以消耗多个数量
2. 总数量是固定的 不能动态增加


 
# Phaser #
 
